#!/usr/bin/env bash
#
# namedlock — Named Lock Tool for Multi-Process Shell Synchronization
#
# Provides acquire/release/wrap primitives keyed by a symbolic name,
# using flock + detached background holder processes.
#
# Usage:
#   namedlock acquire <name> [--wait] [--timeout <seconds>]
#   namedlock release <name>
#   namedlock status  [<name>]
#   namedlock list
#   namedlock wrap <name> [--wait] [--timeout <secs>] -- <cmd> [args…]
#
# Exit codes:
#   0   Success
#   1   Lock already held (acquire without --wait), or release/wrap error
#   2   Invalid arguments
#   75  Timeout waiting for lock (EX_TEMPFAIL)
#
# Environment:
#   NAMEDLOCK_DIR   Override lock directory (default: see resolution below)
#   NAMEDLOCK_LOG   If set, append structured log lines to this file
#
# Lock directory (first match wins):
#   $NAMEDLOCK_DIR
#   $XDG_RUNTIME_DIR/namedlock
#   $HOME/.cache/namedlock
#

set -euo pipefail

# ── Constants ─────────────────────────────────────────────────────────────────

readonly TOOL_NAME="namedlock"
readonly NAME_PATTERN='^[a-zA-Z0-9_.-]+$'

# ── Lock directory resolution ─────────────────────────────────────────────────

resolve_lock_dir() {
    if [[ -n "${NAMEDLOCK_DIR:-}" ]]; then
        printf '%s' "$NAMEDLOCK_DIR"
    elif [[ -n "${XDG_RUNTIME_DIR:-}" ]]; then
        printf '%s' "$XDG_RUNTIME_DIR/namedlock"
    else
        printf '%s' "${HOME}/.cache/namedlock"
    fi
}

# ── Logging ───────────────────────────────────────────────────────────────────

log() {
    local level="$1"
    shift
    local msg="[$(date '+%Y-%m-%d %H:%M:%S')] [$level] [$TOOL_NAME] $*"
    if [[ -n "${NAMEDLOCK_LOG:-}" ]]; then
        printf '%s\n' "$msg" >> "$NAMEDLOCK_LOG"
    fi
    if [[ "$level" == "ERROR" || "$level" == "WARN" ]]; then
        printf '%s\n' "$msg" >&2
    fi
}

# ── Validation ────────────────────────────────────────────────────────────────

validate_name() {
    local name="$1"
    if [[ -z "$name" ]]; then
        printf 'namedlock: lock name is required\n' >&2
        exit 2
    fi
    if [[ ! "$name" =~ $NAME_PATTERN ]]; then
        printf 'namedlock: invalid lock name %q (allowed: [a-zA-Z0-9_.-])\n' "$name" >&2
        exit 2
    fi
}

# ── Stale detection / cleanup ─────────────────────────────────────────────────
#
# Returns:
#   0  — no live lock (cleaned up any stale files)
#   1  — live lock exists (pidfile present + process is running)

clean_stale_if_any() {
    local pidfile="$1"
    local lockfile="$2"
    if [[ -f "$pidfile" ]]; then
        local pid
        pid=$(cat "$pidfile" 2>/dev/null || true)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            return 1  # Live lock
        fi
        log "INFO" "Stale pidfile found (PID=${pid:-?}), cleaning up"
        rm -f "$pidfile" "$lockfile"
    fi
    return 0
}

# ── acquire ───────────────────────────────────────────────────────────────────

cmd_acquire() {
    local name=""
    local do_wait=false
    local timeout=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --wait)
                do_wait=true
                shift
                ;;
            --timeout)
                if [[ $# -lt 2 || -z "${2:-}" ]]; then
                    printf 'namedlock acquire: --timeout requires a numeric value\n' >&2
                    exit 2
                fi
                timeout="$2"
                do_wait=true  # --timeout implies --wait
                shift 2
                ;;
            --)
                shift
                break
                ;;
            -*)
                printf 'namedlock acquire: unknown option %q\n' "$1" >&2
                exit 2
                ;;
            *)
                if [[ -z "$name" ]]; then
                    name="$1"
                    shift
                else
                    printf 'namedlock acquire: unexpected argument %q\n' "$1" >&2
                    exit 2
                fi
                ;;
        esac
    done

    validate_name "$name"

    local lock_dir
    lock_dir=$(resolve_lock_dir)
    mkdir -p "$lock_dir"

    local lockfile="$lock_dir/${name}.lock"
    local pidfile="$lock_dir/${name}.pid"
    local tmppidfile="${pidfile}.tmp"

    # Check/clean stale pidfile; bail early in non-wait mode if live lock exists
    if ! clean_stale_if_any "$pidfile" "$lockfile"; then
        if [[ "$do_wait" == false ]]; then
            local existing_pid
            existing_pid=$(cat "$pidfile" 2>/dev/null || printf '?')
            log "WARN" "acquire '$name': lock already held by PID $existing_pid"
            exit 1
        fi
        # --wait mode: fall through — holder will block on flock
    fi

    # Build the flock invocation for the holder subshell
    local flock_cmd
    if [[ "$do_wait" == false ]]; then
        flock_cmd="flock -n -x 9"
    elif [[ -n "$timeout" ]]; then
        flock_cmd="flock -w ${timeout} -x 9"
    else
        flock_cmd="flock -x 9"
    fi

    log "INFO" "Acquiring lock '$name'${do_wait:+ (blocking${timeout:+, timeout=${timeout}s})}"

    # Spawn a detached background holder process that holds fd 9 open.
    # Uses $BASHPID (not $$) to get the correct PID inside the subshell.
    # Atomic pidfile write: write to .tmp then mv to avoid partial reads.
    nohup bash -c "
        set -euo pipefail
        exec 9>\"${lockfile}\"
        if ! ${flock_cmd}; then
            exit 1
        fi
        echo \$BASHPID > \"${tmppidfile}\" && mv \"${tmppidfile}\" \"${pidfile}\"
        exec sleep infinity
    " </dev/null >/dev/null 2>&1 &
    local holder_bg_pid=$!
    disown

    # Poll for the pidfile to confirm the holder acquired the lock and started.
    # Also fast-fail if the holder process dies without writing the pidfile.
    local max_polls
    if [[ "$do_wait" == false ]]; then
        max_polls=30          # 3 seconds (30 × 0.1 s)
    elif [[ -n "$timeout" ]]; then
        max_polls=$(( (timeout + 5) * 10 ))
    else
        max_polls=-1          # poll indefinitely
    fi

    local polls=0
    while true; do
        # Fast-fail: if our holder process died without writing its own PID,
        # flock either failed immediately (non-wait) or timed out (--wait).
        # We must check for *our* holder's PID specifically, because in --wait
        # mode a previous holder's pidfile may still exist until we acquire.
        if ! kill -0 "$holder_bg_pid" 2>/dev/null; then
            local dead_pid
            dead_pid=$(cat "$pidfile" 2>/dev/null || true)
            if [[ "$dead_pid" != "$holder_bg_pid" ]]; then
                rm -f "$lockfile" 2>/dev/null || true
                if [[ "$do_wait" == true ]]; then
                    log "WARN" "Timeout waiting for lock '$name'${timeout:+ (${timeout}s)}"
                    exit 75
                else
                    log "ERROR" "acquire '$name': lock already held"
                    exit 1
                fi
            fi
        fi

        if [[ -f "$pidfile" ]]; then
            local holder_pid
            holder_pid=$(cat "$pidfile" 2>/dev/null || true)
            # Only accept our holder's PID — not a previous holder's stale entry
            if [[ -n "$holder_pid" && "$holder_pid" == "$holder_bg_pid" ]] && kill -0 "$holder_pid" 2>/dev/null; then
                log "INFO" "Lock '$name' acquired (holder PID=$holder_pid)"
                printf '%s\n' "$holder_pid"
                return 0
            fi
        fi

        sleep 0.1
        polls=$(( polls + 1 ))
        if [[ $max_polls -ge 0 && $polls -ge $max_polls ]]; then
            rm -f "$pidfile" "$lockfile" 2>/dev/null || true
            if [[ "$do_wait" == true ]]; then
                log "WARN" "Timeout waiting for lock '$name'${timeout:+ (${timeout}s)}"
                exit 75
            else
                log "ERROR" "acquire '$name': holder did not start within 3s"
                exit 1
            fi
        fi
    done
}

# ── release ───────────────────────────────────────────────────────────────────
#
# Always returns 0 — never fails the caller's cleanup phase.

cmd_release() {
    local name="${1:-}"

    # Soft validation: release must never fail the caller
    if [[ -z "$name" || ! "$name" =~ $NAME_PATTERN ]]; then
        log "WARN" "release: invalid or missing lock name '${name:-}'"
        return 0
    fi

    local lock_dir
    lock_dir=$(resolve_lock_dir)
    local lockfile="$lock_dir/${name}.lock"
    local pidfile="$lock_dir/${name}.pid"

    if [[ ! -f "$pidfile" ]]; then
        log "WARN" "release '$name': no pidfile found (lock may not be held)"
        return 0
    fi

    local pid
    pid=$(cat "$pidfile" 2>/dev/null || true)

    if [[ -z "$pid" ]]; then
        log "WARN" "release '$name': pidfile is empty"
        rm -f "$pidfile" "$lockfile" 2>/dev/null || true
        return 0
    fi

    if kill -0 "$pid" 2>/dev/null; then
        kill "$pid" 2>/dev/null || true
        sleep 0.5
        if kill -0 "$pid" 2>/dev/null; then
            kill -9 "$pid" 2>/dev/null || true
        fi
        log "INFO" "release '$name': killed holder PID $pid"
    else
        log "WARN" "release '$name': holder PID $pid not found (stale?)"
    fi

    # Only remove the pidfile if it still contains the PID we released.
    # A concurrent --wait acquire may have already written its own PID;
    # removing that pidfile would make the parent poll loop time out.
    local current_pid
    current_pid=$(cat "$pidfile" 2>/dev/null || true)
    if [[ -z "$current_pid" || "$current_pid" == "$pid" ]]; then
        rm -f "$pidfile" "$lockfile" 2>/dev/null || true
    fi
    return 0
}

# ── status ────────────────────────────────────────────────────────────────────

_status_one() {
    local name="$1"
    local lock_dir="$2"
    local lockfile="$lock_dir/${name}.lock"
    local pidfile="$lock_dir/${name}.pid"

    if [[ ! -f "$pidfile" && ! -f "$lockfile" ]]; then
        printf '%-24s  FREE\n' "$name"
        return
    fi

    if [[ -f "$pidfile" ]]; then
        local pid
        pid=$(cat "$pidfile" 2>/dev/null || true)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            local etime
            etime=$(ps -o etimes= -p "$pid" 2>/dev/null | tr -d ' ' || printf '?')
            printf '%-24s  HELD by PID %-8s  (runtime: %ss)\n' "$name" "$pid" "$etime"
        else
            printf '%-24s  STALE (PID %s not running)\n' "$name" "${pid:-?}"
        fi
    else
        printf '%-24s  STALE (lockfile only, no pidfile)\n' "$name"
    fi
}

cmd_status() {
    local name="${1:-}"
    local lock_dir
    lock_dir=$(resolve_lock_dir)

    if [[ -n "$name" ]]; then
        validate_name "$name"
        _status_one "$name" "$lock_dir"
        return 0
    fi

    if [[ ! -d "$lock_dir" ]]; then
        printf '(no lock directory at %s)\n' "$lock_dir"
        return 0
    fi

    local found=false

    # Show all locks from pidfiles
    local pidfile bname
    for pidfile in "$lock_dir"/*.pid; do
        [[ -e "$pidfile" ]] || continue
        bname=$(basename "$pidfile" .pid)
        _status_one "$bname" "$lock_dir"
        found=true
    done

    # Also show orphaned lockfiles (no matching pidfile)
    local lockfile
    for lockfile in "$lock_dir"/*.lock; do
        [[ -e "$lockfile" ]] || continue
        bname=$(basename "$lockfile" .lock)
        [[ -f "$lock_dir/${bname}.pid" ]] && continue  # already shown above
        _status_one "$bname" "$lock_dir"
        found=true
    done

    if [[ "$found" == false ]]; then
        printf '(no locks in %s)\n' "$lock_dir"
    fi
}

# ── list ──────────────────────────────────────────────────────────────────────

cmd_list() {
    local lock_dir
    lock_dir=$(resolve_lock_dir)
    [[ -d "$lock_dir" ]] || return 0

    local pidfile name pid
    for pidfile in "$lock_dir"/*.pid; do
        [[ -e "$pidfile" ]] || continue
        name=$(basename "$pidfile" .pid)
        pid=$(cat "$pidfile" 2>/dev/null || true)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            printf '%s\n' "$name"
        fi
    done
}

# ── wrap ──────────────────────────────────────────────────────────────────────

cmd_wrap() {
    local name=""
    local acquire_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --)
                shift
                break
                ;;
            --wait)
                acquire_args+=("--wait")
                shift
                ;;
            --timeout)
                if [[ $# -lt 2 || -z "${2:-}" ]]; then
                    printf 'namedlock wrap: --timeout requires a numeric value\n' >&2
                    exit 2
                fi
                acquire_args+=("--timeout" "$2")
                shift 2
                ;;
            -*)
                printf 'namedlock wrap: unknown option %q\n' "$1" >&2
                exit 2
                ;;
            *)
                if [[ -z "$name" ]]; then
                    name="$1"
                    shift
                else
                    printf 'namedlock wrap: unexpected argument %q (missing -- before command?)\n' "$1" >&2
                    exit 2
                fi
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        printf 'namedlock wrap: lock name is required\n' >&2
        exit 2
    fi
    if [[ $# -eq 0 ]]; then
        printf 'namedlock wrap: command required after --\n' >&2
        exit 2
    fi

    # Acquire lock; suppress PID echo to stdout (errors still reach stderr via log)
    cmd_acquire "$name" "${acquire_args[@]+"${acquire_args[@]}"}" >/dev/null

    # Ensure lock is released on any exit path
    # shellcheck disable=SC2064
    trap "cmd_release '$name'" EXIT INT TERM HUP

    # Run the wrapped command
    local cmd_exit=0
    "$@" || cmd_exit=$?

    # Explicit release — clear trap first to prevent double-release
    trap - EXIT INT TERM HUP
    cmd_release "$name"

    return $cmd_exit
}

# ── usage ─────────────────────────────────────────────────────────────────────

usage() {
    cat >&2 <<'EOF'
namedlock — Named Lock Tool for Multi-Process Shell Synchronization

Usage:
  namedlock acquire <name> [--wait] [--timeout <seconds>]
  namedlock release <name>
  namedlock status  [<name>]
  namedlock list
  namedlock wrap <name> [--wait] [--timeout <secs>] -- <cmd> [args…]
  namedlock --help

Lock name characters: [a-zA-Z0-9_.-]

Exit codes:
  0   Success
  1   Lock already held (acquire without --wait), or release/wrap error
  2   Invalid arguments
  75  Timeout waiting for lock (EX_TEMPFAIL)

Environment:
  NAMEDLOCK_DIR   Override lock directory
  NAMEDLOCK_LOG   Append structured log lines to this file

Lock directory (first match wins):
  $NAMEDLOCK_DIR
  $XDG_RUNTIME_DIR/namedlock
  $HOME/.cache/namedlock
EOF
}

# ── main ──────────────────────────────────────────────────────────────────────

main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 2
    fi

    local subcmd="$1"
    shift

    case "$subcmd" in
        acquire)        cmd_acquire "$@" ;;
        release)        cmd_release "$@" ;;
        status)         cmd_status  "$@" ;;
        list)           cmd_list    "$@" ;;
        wrap)           cmd_wrap    "$@" ;;
        --help|-h|help) usage; exit 0 ;;
        *)
            printf 'namedlock: unknown command %q\n' "$subcmd" >&2
            usage
            exit 2
            ;;
    esac
}

main "$@"
